// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium datavolumes.cdi.kubevirt.io -A
// kopium version: 0.16.2

use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;
use kube::CustomResource;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use std::collections::BTreeMap;

/// DataVolumeSpec defines the DataVolume type specification
#[derive(CustomResource, Serialize, Deserialize, Clone, Debug, JsonSchema, Default)]
#[kube(
    group = "cdi.kubevirt.io",
    version = "v1beta1",
    kind = "DataVolume",
    plural = "datavolumes"
)]
#[kube(namespaced)]
#[kube(status = "DataVolumeStatus")]
pub struct DataVolumeSpec {
    /// Checkpoints is a list of DataVolumeCheckpoints, representing stages in a multistage import.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub checkpoints: Option<Vec<DataVolumeCheckpoints>>,
    /// DataVolumeContentType options: "kubevirt", "archive"
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "contentType")]
    pub content_type: Option<DataVolumeContentType>,
    /// FinalCheckpoint indicates whether the current DataVolumeCheckpoint is the final checkpoint.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "finalCheckpoint")]
    pub final_checkpoint: Option<bool>,
    /// Preallocation controls whether storage for DataVolumes should be allocated in advance.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub preallocation: Option<bool>,
    /// PriorityClassName for Importer, Cloner and Uploader pod
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "priorityClassName"
    )]
    pub priority_class_name: Option<String>,
    /// PVC is the PVC specification
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pvc: Option<DataVolumePvc>,
    /// Source is the src of the data for the requested DataVolume
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub source: Option<DataVolumeSource>,
    /// SourceRef is an indirect reference to the source of data for the requested DataVolume
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "sourceRef")]
    pub source_ref: Option<DataVolumeSourceRef>,
    /// Storage is the requested storage specification
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub storage: Option<DataVolumeStorage>,
}

/// DataVolumeCheckpoint defines a stage in a warm migration.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema, Default)]
pub struct DataVolumeCheckpoints {
    /// Current is the identifier of the snapshot created for this checkpoint.
    pub current: String,
    /// Previous is the identifier of the snapshot from the previous checkpoint.
    pub previous: String,
}

/// DataVolumeSpec defines the DataVolume type specification
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema, Default)]
pub enum DataVolumeContentType {
    #[serde(rename = "kubevirt")]
    #[default]
    Kubevirt,
    #[serde(rename = "archive")]
    Archive,
}

/// PVC is the PVC specification
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema, Default)]
pub struct DataVolumePvc {
    /// accessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessModes")]
    pub access_modes: Option<Vec<String>>,
    /// dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef, and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified. If the namespace is specified, then dataSourceRef will not be copied to dataSource.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSource")]
    pub data_source: Option<DataVolumePvcDataSource>,
    /// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the dataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, when namespace isn't specified in dataSourceRef, both fields (dataSource and dataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. When namespace is specified in dataSourceRef, dataSource isn't set to the same value and must be empty. There are three important differences between dataSource and dataSourceRef: * While dataSource only allows two specific types of objects, dataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While dataSource ignores disallowed values (dropping them), dataSourceRef preserves all values, and generates an error if a disallowed value is specified. * While dataSource only allows local objects, dataSourceRef allows objects in any namespaces. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled. (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSourceRef")]
    pub data_source_ref: Option<DataVolumePvcDataSourceRef>,
    /// resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<DataVolumePvcResources>,
    /// selector is a label query over volumes to consider for binding.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<DataVolumePvcSelector>,
    /// storageClassName is the name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClassName")]
    pub storage_class_name: Option<String>,
    /// volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMode")]
    pub volume_mode: Option<String>,
    /// volumeName is the binding reference to the PersistentVolume backing this claim.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
}

/// dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef, and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified. If the namespace is specified, then dataSourceRef will not be copied to dataSource.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema, Default)]
pub struct DataVolumePvcDataSource {
    /// APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
}

/// dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the dataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, when namespace isn't specified in dataSourceRef, both fields (dataSource and dataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. When namespace is specified in dataSourceRef, dataSource isn't set to the same value and must be empty. There are three important differences between dataSource and dataSourceRef: * While dataSource only allows two specific types of objects, dataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While dataSource ignores disallowed values (dropping them), dataSourceRef preserves all values, and generates an error if a disallowed value is specified. * While dataSource only allows local objects, dataSourceRef allows objects in any namespaces. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled. (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema, Default)]
pub struct DataVolumePvcDataSourceRef {
    /// APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
    /// Namespace is the namespace of resource being referenced Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details. (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema, Default)]
pub struct DataVolumePvcResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container.
    ///  This is an alpha field and requires enabling the DynamicResourceAllocation feature gate.
    ///  This field is immutable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<DataVolumePvcResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, String>>,
    /// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, String>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema, Default)]
pub struct DataVolumePvcResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
    pub name: String,
}

/// selector is a label query over volumes to consider for binding.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema, Default)]
pub struct DataVolumePvcSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<DataVolumePvcSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema, Default)]
pub struct DataVolumePvcSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// Source is the src of the data for the requested DataVolume
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema, Default)]
pub struct DataVolumeSource {
    /// DataVolumeBlankImage provides the parameters to create a new raw blank image for the PVC
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub blank: Option<DataVolumeSourceBlank>,
    /// DataVolumeSourceGCS provides the parameters to create a Data Volume from an GCS source
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gcs: Option<DataVolumeSourceGcs>,
    /// DataVolumeSourceHTTP can be either an http or https endpoint, with an optional basic auth user name and password, and an optional configmap containing additional CAs
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub http: Option<DataVolumeSourceHttp>,
    /// DataVolumeSourceImageIO provides the parameters to create a Data Volume from an imageio source
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub imageio: Option<DataVolumeSourceImageio>,
    /// DataVolumeSourcePVC provides the parameters to create a Data Volume from an existing PVC
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pvc: Option<DataVolumeSourcePvc>,
    /// DataVolumeSourceRegistry provides the parameters to create a Data Volume from an registry source
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub registry: Option<DataVolumeSourceRegistry>,
    /// DataVolumeSourceS3 provides the parameters to create a Data Volume from an S3 source
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub s3: Option<DataVolumeSourceS3>,
    /// DataVolumeSourceSnapshot provides the parameters to create a Data Volume from an existing VolumeSnapshot
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub snapshot: Option<DataVolumeSourceSnapshot>,
    /// DataVolumeSourceUpload provides the parameters to create a Data Volume by uploading the source
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub upload: Option<DataVolumeSourceUpload>,
    /// DataVolumeSourceVDDK provides the parameters to create a Data Volume from a Vmware source
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub vddk: Option<DataVolumeSourceVddk>,
}

/// DataVolumeBlankImage provides the parameters to create a new raw blank image for the PVC
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema, Default)]
pub struct DataVolumeSourceBlank {}

/// DataVolumeSourceGCS provides the parameters to create a Data Volume from an GCS source
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema, Default)]
pub struct DataVolumeSourceGcs {
    /// SecretRef provides the secret reference needed to access the GCS source
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<String>,
    /// URL is the url of the GCS source
    pub url: String,
}

/// DataVolumeSourceHTTP can be either an http or https endpoint, with an optional basic auth user name and password, and an optional configmap containing additional CAs
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema, Default)]
pub struct DataVolumeSourceHttp {
    /// CertConfigMap is a configmap reference, containing a Certificate Authority(CA) public key, and a base64 encoded pem certificate
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certConfigMap")]
    pub cert_config_map: Option<String>,
    /// ExtraHeaders is a list of strings containing extra headers to include with HTTP transfer requests
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "extraHeaders")]
    pub extra_headers: Option<Vec<String>>,
    /// SecretExtraHeaders is a list of Secret references, each containing an extra HTTP header that may include sensitive information
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "secretExtraHeaders"
    )]
    pub secret_extra_headers: Option<Vec<String>>,
    /// SecretRef A Secret reference, the secret should contain accessKeyId (user name) base64 encoded, and secretKey (password) also base64 encoded
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<String>,
    /// URL is the URL of the http(s) endpoint
    pub url: String,
}

/// DataVolumeSourceImageIO provides the parameters to create a Data Volume from an imageio source
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema, Default)]
pub struct DataVolumeSourceImageio {
    /// CertConfigMap provides a reference to the CA cert
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certConfigMap")]
    pub cert_config_map: Option<String>,
    /// DiskID provides id of a disk to be imported
    #[serde(rename = "diskId")]
    pub disk_id: String,
    /// SecretRef provides the secret reference needed to access the ovirt-engine
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<String>,
    /// URL is the URL of the ovirt-engine
    pub url: String,
}

/// DataVolumeSourcePVC provides the parameters to create a Data Volume from an existing PVC
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema, Default)]
pub struct DataVolumeSourcePvc {
    /// The name of the source PVC
    pub name: String,
    /// The namespace of the source PVC
    pub namespace: String,
}

/// DataVolumeSourceRegistry provides the parameters to create a Data Volume from an registry source
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema, Default)]
pub struct DataVolumeSourceRegistry {
    /// CertConfigMap provides a reference to the Registry certs
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certConfigMap")]
    pub cert_config_map: Option<String>,
    /// ImageStream is the name of image stream for import
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "imageStream")]
    pub image_stream: Option<String>,
    /// PullMethod can be either "pod" (default import), or "node" (node docker cache based import)
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "pullMethod")]
    pub pull_method: Option<String>,
    /// SecretRef provides the secret reference needed to access the Registry source
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<String>,
    /// URL is the url of the registry source (starting with the scheme: docker, oci-archive)
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
}

/// DataVolumeSourceS3 provides the parameters to create a Data Volume from an S3 source
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema, Default)]
pub struct DataVolumeSourceS3 {
    /// CertConfigMap is a configmap reference, containing a Certificate Authority(CA) public key, and a base64 encoded pem certificate
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "certConfigMap")]
    pub cert_config_map: Option<String>,
    /// SecretRef provides the secret reference needed to access the S3 source
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<String>,
    /// URL is the url of the S3 source
    pub url: String,
}

/// DataVolumeSourceSnapshot provides the parameters to create a Data Volume from an existing VolumeSnapshot
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema, Default)]
pub struct DataVolumeSourceSnapshot {
    /// The name of the source VolumeSnapshot
    pub name: String,
    /// The namespace of the source VolumeSnapshot
    pub namespace: String,
}

/// DataVolumeSourceUpload provides the parameters to create a Data Volume by uploading the source
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema, Default)]
pub struct DataVolumeSourceUpload {}

/// DataVolumeSourceVDDK provides the parameters to create a Data Volume from a Vmware source
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema, Default)]
pub struct DataVolumeSourceVddk {
    /// BackingFile is the path to the virtual hard disk to migrate from vCenter/ESXi
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "backingFile")]
    pub backing_file: Option<String>,
    /// InitImageURL is an optional URL to an image containing an extracted VDDK library, overrides v2v-vmware config map
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "initImageURL")]
    pub init_image_url: Option<String>,
    /// SecretRef provides a reference to a secret containing the username and password needed to access the vCenter or ESXi host
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "secretRef")]
    pub secret_ref: Option<String>,
    /// Thumbprint is the certificate thumbprint of the vCenter or ESXi host
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub thumbprint: Option<String>,
    /// URL is the URL of the vCenter or ESXi host with the VM to migrate
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<String>,
    /// UUID is the UUID of the virtual machine that the backing file is attached to in vCenter/ESXi
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub uuid: Option<String>,
}

/// SourceRef is an indirect reference to the source of data for the requested DataVolume
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema, Default)]
pub struct DataVolumeSourceRef {
    /// The kind of the source reference, currently only "DataSource" is supported
    pub kind: String,
    /// The name of the source reference
    pub name: String,
    /// The namespace of the source reference, defaults to the DataVolume namespace
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// Storage is the requested storage specification
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema, Default)]
pub struct DataVolumeStorage {
    /// AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "accessModes")]
    pub access_modes: Option<Vec<String>>,
    /// This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) * An existing custom resource that implements data population (Alpha) In order to use custom resource types that implement data population, the AnyVolumeDataSource feature gate must be enabled. If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSource")]
    pub data_source: Option<DataVolumeStorageDataSource>,
    /// Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef preserves all values, and generates an error if a disallowed value is specified. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "dataSourceRef")]
    pub data_source_ref: Option<DataVolumeStorageDataSourceRef>,
    /// Resources represents the minimum resources the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub resources: Option<DataVolumeStorageResources>,
    /// A label query over volumes to consider for binding.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub selector: Option<DataVolumeStorageSelector>,
    /// Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "storageClassName")]
    pub storage_class_name: Option<String>,
    /// volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeMode")]
    pub volume_mode: Option<String>,
    /// VolumeName is the binding reference to the PersistentVolume backing this claim.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "volumeName")]
    pub volume_name: Option<String>,
}

/// This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) * An existing custom resource that implements data population (Alpha) In order to use custom resource types that implement data population, the AnyVolumeDataSource feature gate must be enabled. If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema, Default)]
pub struct DataVolumeStorageDataSource {
    /// APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
}

/// Specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef preserves all values, and generates an error if a disallowed value is specified. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema, Default)]
pub struct DataVolumeStorageDataSourceRef {
    /// APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "apiGroup")]
    pub api_group: Option<String>,
    /// Kind is the type of resource being referenced
    pub kind: String,
    /// Name is the name of resource being referenced
    pub name: String,
    /// Namespace is the namespace of resource being referenced Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details. (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub namespace: Option<String>,
}

/// Resources represents the minimum resources the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema, Default)]
pub struct DataVolumeStorageResources {
    /// Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container.
    ///  This is an alpha field and requires enabling the DynamicResourceAllocation feature gate.
    ///  This field is immutable.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub claims: Option<Vec<DataVolumeStorageResourcesClaims>>,
    /// Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limits: Option<BTreeMap<String, String>>,
    /// Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub requests: Option<BTreeMap<String, String>>,
}

/// ResourceClaim references one entry in PodSpec.ResourceClaims.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema)]
pub struct DataVolumeStorageResourcesClaims {
    /// Name must match the name of one entry in pod.spec.resourceClaims of the Pod where this field is used. It makes that resource available inside a container.
    pub name: String,
}

/// A label query over volumes to consider for binding.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema, Default)]
pub struct DataVolumeStorageSelector {
    /// matchExpressions is a list of label selector requirements. The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<DataVolumeStorageSelectorMatchExpressions>>,
    /// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchLabels")]
    pub match_labels: Option<BTreeMap<String, String>>,
}

/// A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema, Default)]
pub struct DataVolumeStorageSelectorMatchExpressions {
    /// key is the label key that the selector applies to.
    pub key: String,
    /// operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
    pub operator: String,
    /// values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

/// DataVolumeStatus contains the current status of the DataVolume
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema, Default)]
pub struct DataVolumeStatus {
    /// ClaimName is the name of the underlying PVC used by the DataVolume.
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "claimName")]
    pub claim_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<DataVolumeStatusConditions>>,
    /// Phase is the current phase of the data volume
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phase: Option<String>,
    /// DataVolumeProgress is the current progress of the DataVolume transfer operation. Value between 0 and 100 inclusive, N/A if not available
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub progress: Option<String>,
    /// RestartCount is the number of times the pod populating the DataVolume has restarted
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "restartCount")]
    pub restart_count: Option<i32>,
}

/// DataVolumeCondition represents the state of a data volume condition.
#[derive(Serialize, Deserialize, Clone, Debug, JsonSchema, Default)]
pub struct DataVolumeStatusConditions {
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lastHeartbeatTime"
    )]
    pub last_heartbeat_time: Option<String>,
    #[serde(
        default,
        skip_serializing_if = "Option::is_none",
        rename = "lastTransitionTime"
    )]
    pub last_transition_time: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    pub status: String,
    /// DataVolumeConditionType is the string representation of known condition types
    #[serde(rename = "type")]
    pub r#type: String,
}
